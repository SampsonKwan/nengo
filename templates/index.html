<!DOCTYPE html>
<html lang="en">
<head>
    <title>Nengo Network Constructor</title>
    <link rel="stylesheet" type="text/css" href="/static/main.css">
    <link rel="stylesheet" type="text/css" href="/static/menu.css">
    <link rel="stylesheet" type="text/css" href="/static/js/jqueryFileTree/jqueryFileTree.css">
</head>
<body onload="open_file('scripts/default.py');">

<script src="/static/js/d3.min.js", type="text/javascript" charset="utf-8"></script>
<script src="/static/js/jquery-1.11.0.min.js", type="text/javascript" charset="utf-8"></script>
<script src="/static/js/jqueryFileTree/jqueryFileTree.js", type="text/javascript" charset="utf-8"></script>

//*************************
// Setup the GUI components
//*************************

//Setup the editor
<script src="/static/js/ace/ace.js" type="text/javascript" charset="utf-8"></script>
<script>
var aceRange = ace.require('ace/range').Range;
</script>
<div id="editor">
</div>

//Load the editor and link it
<script> 
var editor = ace.edit("editor");
editor.setTheme("ace/theme/monokai");
editor.getSession().setMode("ace/mode/python");

editor.on('change', function(event) {reload_graph_data();});
</script> 

//Setup the main graphical window
<div id="graph">
    <svg>
        <defs>
            // the arrow on the links
            <marker id="TriangleMarker"
              viewBox="0 0 10 10" refX="0" refY="5"
              markerUnits="strokeWidth"
              markerWidth="6" markerHeight="4"
              orient="auto">
              <path d="M 0 0 L 10 5 L 0 10 z" />
            </marker>
            <g id ="ensemble" transform="translate(-17.2735,-17.7015)"> 
                <circle cx="4.843" cy="10.519" r="4.843"/>
                <circle cx="16.186" cy="17.873" r="4.843"/>
                <circle cx="21.012" cy="30.56" r="4.843"/>
                <circle cx="29.704" cy="17.229" r="4.843"/>
                <circle cx="5.647" cy="26.413" r="4.843"/>
                <circle cx="19.894" cy="4.842" r="4.843"/>
            </g>
            <g id = "recur" transform="translate(-20,-34)">
            <path 
                d="M6.451,28.748C2.448,26.041,0,22.413,0,18.425C0,
                    10.051,10.801,3.262,24.125,3.262
                S48.25,10.051,48.25,18.425c0,6.453-6.412,11.964-15.45,14.153"/>
            <path fill="black" stroke-width="1" stroke="black" stroke-opacity="1" 
                d="M30.632,6.523l-6.524-3.262L30.632,0V6.523z"/>
            </g>
        </defs>
    </svg>
</div>

//Setup the menu bar
<div id="menubar">
    <img id="menu_open" src="/static/img/open.png" title="open model"/>
    <img id="menu_save" src="/static/img/savefile.png" title="save model"/>
</div>

//Setup a file browser
<div id="filebrowser"></div>
<script>
$('#filebrowser').hide()
$('#menu_open').click(function() {$('#filebrowser').toggle(200);})
$('#filebrowser').fileTree({ root: '.', script: '/browse' }, open_file);

function open_file(file) {
    $('#filebrowser').hide();

    container.selectAll('.link').remove();
    container.selectAll('.node').remove();
    editor.setValue('');

    var data = new FormData();
    data.append('filename', file);

    var xhr = new XMLHttpRequest();
    xhr.open('POST', '/openfile', true);
    xhr.onload = function(event) {editor.setValue(this.responseText);};
    xhr.send(data);
}
</script>

//*****************
// Helper functions
//*****************
<script>
//**************
// Drag and zoom
//**************
function dragstarted(d) {
      d3.event.sourceEvent.stopPropagation();
      d3.select(this).classed("dragging", true);
}

function dragged(d) {
    d.x = d3.event.x;
    d.y = d3.event.y;

    d3.select(this).attr('transform', "translate("+d.x+","+d.y+")");

    var node_list = d3.map(graph.nodes) //create a map of the nodes
    update_node_positions(d, d3.event.dx, d3.event.dy, node_list);
    update_net_sizes();
    update_net_position(d, d3.event.dx, d3.event.dy);
    update_line_locations();
}

function dragended(d) {
      d3.select(this).classed("dragging", false);
}

function zoomed() {
    container.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
}

//*********************
// Link graph to editor
//*********************
//Link mouse in graph to editor changes
function mouseover(d) {
	if (marker!=null) {
		editor.getSession().removeMarker(marker);
		marker = null;
		}
	marker = editor.getSession().addMarker(new aceRange(d.line, 0, d.line, 10), 'highlight', 'fullLine', true);
	editor.getSession().setAnnotations([{row: d.line, type:'info'}]);
	}
	
function mouseout(d) {
	if (marker!=null) {
		editor.getSession().removeMarker(marker);
		marker = null;
		}
	editor.getSession().clearAnnotations();
	}

//*****************
// Reload the graph
//*****************
//Send the editor data to the server
function reload_graph_data() {
    var data = new FormData();
    data.append('code', editor.getValue());

    var xhr = new XMLHttpRequest();
    xhr.open('POST', '/graph.json', true);
    xhr.onload = update_graph;
    xhr.send(data);
}

//Redraw the graph given server response
function update_graph() {
	graph = JSON.parse(this.responseText);

	// was there a parsing error?
	if (graph.error_line != undefined) {
		if (marker!=null) {
			editor.getSession().removeMarker(marker);
			marker = null;
			}
		marker = editor.getSession().addMarker(new aceRange(graph.error_line-1, 0, graph.error_line-1, 10), 'highlight', 'fullLine', true);
		editor.getSession().setAnnotations([{row: graph.error_line-1, type:'error'}]);
		return;
	} else {
		if (marker!=null) {
			editor.getSession().removeMarker(marker);
			marker = null;
			}
		editor.getSession().clearAnnotations();
	}

	//separate links into recurrent and nonrecurrent ?move to convert?	
	var nonrecurlink = []
	var recurlink = []
	for (i in graph.links) {
	    if (graph.links[i].target!=graph.links[i].source) {
	        nonrecurlink.push(graph.links[i])
	    } else {
	        recurlink.push(graph.links[i])
	    }
	}
	
	//update the links
	link = container.selectAll('.link.link_std, .link.link_net')
		.data(nonrecurlink, function(d) {return d.id})
	link.enter().append('polyline')
		.attr('class', function(d) {return 'link link_'+d.type;})

	linkRecur = container.selectAll('.link.link_recur')
		.data(recurlink, function(d) {return d.id})
	linkRecur.enter().append('use')
	    .attr('class', function(d) {return 'link link_recur';})
	    .attr('xlink:href', "#recur")	

	//get all the nodes, for updating
	node = container.selectAll('g.node')
		.data(graph.nodes, function(d) {return d.id})
	container.selectAll('g.node text')
		.data(graph.nodes, function(d) {return d.id})
    
    //Create html objects to draw
	var nodeEnter = node
		.enter()
		.append('g')
		.attr('class', function(d) {return 'node node_'+d.type;})
		.on('mouseover', mouseover)
		.on('mouseout', mouseout)
		.call(drag);

/*	nodeEnter.filter(function(d,i) {
	    for (ind in recurlink) {
	        if (i==recurlink[ind].target) {
	            return true
	        } else {
	        return false
	        }
	    }})
		.append('use')
		.attr('class', function(d) {return 'link link_recur';})
		.attr('xlink:href', "#recur")
*/
	nodeEnter.filter(function(d) {return d.type=='ens';})
		.append('use')
		.attr('xlink:href', "#ensemble")
		
	nodeEnter.filter(function(d) {return d.type=='nde';})
		.append('circle')
		.attr('r', '20')

	nodeEnter.filter(function(d) {return d.type=='net';})
		.append('rect')
		.attr('x', '-50')
		.attr('y', '-50')
		.attr('rx', '15')
		.attr('ry', '15')
		.attr('width', '100')
		.attr('height', '100')

	nodeEnter.append('text')
		.attr('y', '30')
		.text(function(d) {return d.label;});
	
	node.exit().remove();
	link.exit().remove();
	linkRecur.exit().remove();

	//label everything
	container.selectAll('g.node')
		.selectAll('text')
		.text(function(d) {return d.label;});
	//redraw so nodes are on top
	container.selectAll('g.node').filter(function(d) {return d.type!='net';})
		.moveToFront();

    update_net_sizes();
	update_line_locations();
}

//***********************
// Drawing graph elements
//***********************
// Move objects to be drawn on top
d3.selection.prototype.moveToFront = function() {
  return this.each(function(){
    this.parentNode.appendChild(this);
  });
};

function update_line_locations() {
    link.filter(function(d) {return d.type=='std';})
        .attr('points', function(d) {
            x0 = graph.nodes[d.source].x;
            y0 = graph.nodes[d.source].y;
            x1 = graph.nodes[d.target].x;
            y1 = graph.nodes[d.target].y;
            return ""+x0+","+y0+" "+(x0*0.45+x1*0.55)+","+(y0*0.45+y1*0.55)+" "+
                      x1+","+y1;
        });
        
    linkRecur
        .attr('x', function(d) {return graph.nodes[d.source].x})
        .attr('y', function(d) {return graph.nodes[d.source].y})
}

//Update all network sizes based on node positions
function update_net_sizes() {
    node.filter(function(d) {return d.type=='net';})
        .each(update_net_size)
        .selectAll('rect')
            .attr('x', function(d) {return -net_widths[d.id]/2;})
            .attr('y', function(d) {return -net_heights[d.id]/2;})
            .attr('width', function(d) {return net_widths[d.id];})
            .attr('height', function(d) {return net_heights[d.id];})
            ;
    node.attr('transform', function(d) {
        return 'translate('+[d.x, d.y]+')';
        });
}

//Update given network size based on node position
function update_net_size(d) {
	xstart = d.x
	ystart = d.y
    x0 = graph.nodes[d.contains[0]].x; //first item in net x,y as a start
    x1 = x0;
    y0 = graph.nodes[d.contains[0]].y;
    y1 = y0;
    for (obj in d.contains) {  //min/max of y and x of nodes in net
        xBorder = 0
        yBorder = 0
        tmp = graph.nodes[d.contains[obj]]
        if (tmp.type =="net") {
            xBorder = net_widths[tmp.id] / 2 - net_inner_margin
            yBorder = net_heights[tmp.id] / 2 - net_inner_margin
        }
        x0 = Math.min(graph.nodes[d.contains[obj]].x-xBorder, x0);
        x1 = Math.max(graph.nodes[d.contains[obj]].x+xBorder, x1);
        y0 = Math.min(graph.nodes[d.contains[obj]].y-yBorder, y0);
        y1 = Math.max(graph.nodes[d.contains[obj]].y+yBorder, y1);
    }
    d.x = (x0+x1)/2;  // x, y mid
    d.y = (y0+y1)/2;
    dx = d.x - xstart;
    dy = d.y - ystart;
    net_widths[d.id] = x1 - x0+2*net_inner_margin; //track heights/widths
    net_heights[d.id] = y1 - y0+2*net_inner_margin;

    
    update_node_positions(d, 2*dx, 2*dy, d3.map(graph.nodes))
}

//Move all the nodes in a network if network position changes
function update_net_position(d, dx, dy) {
    if (d.type == "net") {
        for (var obj in d.contains) {
            if (graph.nodes[d.contains[obj]].type == "net") {
                update_net_position(graph.nodes[d.contains[obj]], dx, dy)
            }
            graph.nodes[d.contains[obj]].x += dx
            graph.nodes[d.contains[obj]].y += dy
        }
    }
}

//Update the position of any nodes and what they affect
function update_node_positions(d, dx, dy, node_list) {
    removeValue(node_list, d)
    for (n in node_list.keys()) {
        if (close_to(node_list.get(node_list.keys()[n]), d)) {
        	move_node(node_list.get(node_list.keys()[n]), dx, dy)
        	update_node_positions(node_list.get(node_list.keys()[n]), 
        	        dx, dy, d3.map(node_list))
        }
    }
}

//Move the provided nodes the provided distance and note that
function move_node(node, dx, dy) {
    if (node.type == "net") { //move a network
        update_net_position(node, dx,dy)
    }
    else{ //move ens or nde
            node.x += dx
            node.y += dy
    }
}

//Redraw if the window is resized
function resize() {
    width = window.innerWidth/2;
    height = window.innerHeight;
    svg.attr("width", width).attr("height", height);
}

//**************
// Miscellaneous
//**************
//Remove object from a map.  Removes all matching items.
function removeValue(map, d) {
    keys = map.keys()
    for (el in map.keys()) {
        if (map.get(map.keys()[el]) == d) {
            map.remove(map.keys()[el])
        }
    }
}

// is the point x, y inside the net
function isin(d, x, y) { 
	return (x<d.x+net_widths[d.id]/2) &&
		   (x>d.x-net_widths[d.id]/2) &&
		   (y<d.y+net_heights[d.id]/2) &&
		   (y>d.y-net_heights[d.id]/2);
}

//Check if node, n is close to origin object, o
function close_to(n, o) { //n is node, o is origin
	if (o.type == "net") { //if origin is net
		if (!(n.type == "net")) { //if node is nde or ens
        	if (!netContains(n, o)) {
            	if (Math.abs(o.x-n.x) < (net_margin+net_widths[o.id]/2) &&
                    Math.abs(o.y-n.y) < (net_margin+net_heights[o.id]/2)) {
                	//console.log('true 1')
                	return true
                }
            }
        }
        else if (!(netContains(n, o) || netContains(o, n))) { //if node is net
            if (Math.abs(o.x-n.x) < (net_widths[n.id]/2+net_widths[o.id]/2)
                && Math.abs(o.y-n.y)<(net_heights[n.id]/2
                                                    +net_heights[o.id]/2)) {
                //console.log('true 2')
            	return true
            }
        }
    }
    else { //if origin is nde or ens
		if (!(n.type == "net")) { //if node nde or ens
			if (Math.abs(o.x-n.x) < node_margin
			   && Math.abs(o.y-n.y) < node_margin) {
             	//console.log('true 3')
				return true
			}
		}
        else { //if node is net
        	if(!netContains(o, n)) {
            	if (Math.abs(o.x-n.x) < (net_margin+net_widths[n.id]/2) &&
                    Math.abs(o.y-n.y) < (net_margin+net_heights[n.id]/2)) {
                	//console.log('true 4')
                	return true
                }
            }
        }
    }
    return false
}

//True if net or any of its subnets contains node
function netContains(node, net) {
    var contain_bool = false
    for (var i in net.contains) {
        if (graph.nodes[net.contains[i]].id == node.id) {
            return true
        }
        else if (graph.nodes[net.contains[i]].type == "net") {
            contain_bool = netContains(node, graph.nodes[net.contains[i]])
            if (contain_bool) {
                return true
            }
        }
    }
    return contain_bool
}
</script>

//***********
//Main script
//***********
<script>
var zoom = d3.behavior.zoom()
    .scaleExtent([0.1, 10])
    .on('zoom', zoomed);

var svg = d3.select("svg");
var container = svg.append('g');

zoom(svg);  // set up zooming on the graph

var drag = d3.behavior.drag()
    .origin(function(d){return d})
    .on('dragstart', dragstarted)
    .on('drag', dragged)
    .on('dragend', dragended);

//**********************
// editor -> server -> graph 
//**********************
var graph;
var link;
var linkRecur;
var node;

// line highlighting when over objects in graph
var marker = null;

reload_graph_data();

var net_widths = {};
var net_heights = {};
var node_margin = 35;
var net_inner_margin = 40;
var net_margin = 15;

d3.select(window).on("resize", resize);
</script>

</body>
</html>
